/*
	This is a SQL Parser and Executor class for the Flava database
	engine.
*/
import java.*;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;
import java.io.File;
import java.io.IOException;
import java.io.FilenameFilter;
import java.io.PrintWriter;
import java.io.BufferedWriter;
import java.io.BufferedReader;
import java.io.FileWriter;
import java.io.FileReader;

/** 
The FlavaParsecutor parses and executes command tokens generated by 
the main Flava program.
 */
public class FlavaSQLParsecutor {
	static ArrayList <String> validCommands = new ArrayList<String>(Arrays.asList("create", 
		"delete", "insert", "select", "update"));
	static ArrayList <String> validObjects = new ArrayList<String>(Arrays.asList("database", 
		"table", "on"));
	static ArrayList <String> validOptions = new ArrayList<String>(Arrays.asList("index", 
		"values", "schema"));
	static ArrayList <String> validOptionParameters = new ArrayList<String>(Arrays.asList("where", "schema"));
	static ArrayList <String> validDatabaseTypes = new ArrayList<String>(Arrays.asList("long", "double", "char", "string", "boolean"));

	private int tokenLength;
	private String [] commandTokens;
	private String command;
	private String objectType;
	private String objectParameter;
	private String option = "";
	private String optionParameter = "";
	private String extendedOption = "";
	private String extendedOptionParameter = "";

	/** 
	The constructor takes an array of strings that have been 
	tokenized into logical and semantically correct Flava
	commands.
	*/
	public FlavaSQLParsecutor (String [] commandTokens) {
		try {
			this.tokenLength = commandTokens.length;
			if (isValidTokenLength(tokenLength) &&
				objectTokensValid(Arrays.copyOfRange(commandTokens, 0, 2))) {

				// Set command and object tokens
				this.command = commandTokens[0].toLowerCase();
				this.objectType = commandTokens[1].toLowerCase();
				this.objectParameter = commandTokens[2];

				if (tokenLength > 3 && 
					optionTokensValid(Arrays.copyOfRange(commandTokens, 3, 5))) {
					// Set optional tokens
					this.option = commandTokens[3].toLowerCase();
					this.optionParameter = commandTokens[4];

					if (tokenLength > 5 && 
						extendedTokensValid(Arrays.copyOfRange(commandTokens, 5, tokenLength))) {
						// Set extended option tokens
						this.extendedOption = commandTokens[5].toLowerCase();
						this.extendedOptionParameter = commandTokens[6];
					}
				}
			}
		} catch (Exception e) {
			System.out.println("CANNOT PARSE YOUR COMMAND! IT CONTAINS INVALID SYNTAX TOKENS!");
		}
	}

	/** The tokenized string array will only have a length of 3, 5, or 7. */
	public static Boolean isValidTokenLength (int length) {
		return (length == 3 || length == 5 || length == 7);
	}

	public static Boolean objectTokensValid (String [] objectTokens) {
		return ((validCommands.contains(objectTokens[0])) &&
				(validObjects.contains(objectTokens[1])));
	}

	public static Boolean optionTokensValid (String [] optionTokens) {
		// Need to validate structure of parameters
		return (validOptions.contains(optionTokens[0]));
	}

	public static Boolean extendedTokensValid (String [] extendedTokens) {
		// Need to validate structure of parameters
		return (extendedTokens[0].contains(extendedTokens[0]));
	}
	/** END Constructor Validation **/

	// Does the command, now that it contains correct tokens, make sense? i.e. Can you "insert on tableName"
	public Boolean isCommandExecutable () {
		return true;
	}

	public void execute () {
		switch (this.command) {
			case "create" :			
				createDatabaseItem();	
				// update database array
				break;
			case "delete" :
				deleteDatabaseItem();
				break;
			case "select" :
				System.out.println("selecting");
				break;
			case "insert" :
				System.out.println("inserting");
				insert();
				break;
			case "update" :
				System.out.println("updating");
				break;
		}
	}

	public String getFolderPath () {
		// TODO: REFACTOR THE STRING LITERALS!
		String folderPath = "./data/";
		if (objectType.equals("database")) {
			folderPath += objectParameter + ".fdb/";
		} else {
			String currentGlobalDatabase = Flava.getCurrentGlobalDatabase(),
				   tableExtension = ".ftl/";
			folderPath += currentGlobalDatabase + objectParameter + tableExtension;

			if (tokenLength > 3 && this.option.equals("index")) {
				System.out.println("THIS: " + tokenLength + ", " + option);
				String indexExtension = ".idx/";
				folderPath += this.optionParameter + indexExtension;
			}
		} 
		// TODO: Remove
		System.out.println("Folder path: " + folderPath);
		return folderPath;
	}

	public String getFilePath (String fileType) {
		String fileName = (option.equals("index")) ? optionParameter : objectParameter;
		// TODO: Remove
		// System.out.println("RETURNING : " + getFolderPath() + fileName + fileType);
		return getFolderPath() + fileName + fileType;
	}

	public void createDatabaseItem () {
		String pathString = getFolderPath();
		File objectFile = new File(pathString);

		if (!objectFile.exists()) {
			try {
				if (this.objectType.equals("database")) {
					objectFile.mkdir();
					Flava.updateDatabaseList();
				} else if ((this.objectType.equals("table") ||
						   option.equals("index")) ) {
					String schema = (this.objectType.equals("table") ? 
									 this.optionParameter : this.extendedOptionParameter);
					schema = removeParens(schema);
					if (isSchemaProperlyFormatted(schema)) {
						objectFile.mkdir();
						File dataFile = new File(getFilePath(".data")),
							 schemaFile = new File(getFilePath(".schema"));
						dataFile.createNewFile();
						schemaFile.createNewFile();
						appendTextToFile(schema, ".schema");
					}
				}
			} catch (IOException io) {
				System.out.println("WHY HERE");
			}
		} else {
			System.out.println("The " + (this.tokenLength > 3 ? this.option : this.objectType) + " " + 
							  (this.tokenLength > 3 ? this.optionParameter : this.objectParameter) + 
							  " already exists! Cannot create a duplicate " + this.objectType);
		}
				
	}

	// Still does not delete recursively yet 
	public void deleteDatabaseItem () {
		File file = new File(getFolderPath());

		if (file.exists()) {
			try {
				String [] filesInFile = file.list();

				for (String fileString : filesInFile) {
				    File currentFile = new File(file.getPath(), fileString);
				    currentFile.delete();
				}
				file.delete();

			} catch (SecurityException se) {
				System.out.println("Cannot delete " + this.objectType + " " + 
								   this.objectParameter + "! You may not have " +
								   "permission to delete this item!");
			}
		} else {
			System.out.println("The " + this.objectType + " " + this.objectParameter + 
				" does not exist!");
		}
	}

	public void insert () {
		// Is object == on && does the tableName exist && is the option values &&
		// are the parameters properly formatted for the table it is being inserted
		// onto (i.e. check against schema)
		File table = new File(getFolderPath());
		if (this.objectType.equals("on") && table.exists() 
			&& this.option.equals("values") && areValuesProperlyFormatted()) {
			System.out.println("WILL INSERT");
			appendTextToFile(removeParens(this.optionParameter), ".data");
		} else {
			Flava.invalidCommand("FlavaSQLParsecutor 222");
		}
	}

	public String removeParens (String stringWithParens) {
		return stringWithParens.substring(1, (stringWithParens.length() - 1));
	}

	public void appendTextToFile (String text, String fileType) {
		PrintWriter out = null;
		try {
		    // TODO REMOVE
		    //System.out.println("FILE PATH : " + getFilePath(fileType));
		    out = new PrintWriter(new BufferedWriter(new FileWriter(getFilePath(fileType), true)));
		    out.println(text);
		} catch (IOException e) {
		    System.err.println("PS 220 : Could not append text to file for some reason");
		} finally {
		    if (out != null){
		        out.close();
		    }
		} 
	}

	/** Check to see if the values can be inserted */
	public Boolean areValuesProperlyFormatted () {
		String [] values = removeParens(this.optionParameter).split("[,\\s]+");
		Flava.printStringArray(values, "values");
		String [] schemaTypes = getSchemaTypes(".schema");
		System.out.println(values.length + " vs. " + schemaTypes.length);
// for every string value in values, i want to try and parse it as the schemaType
		if (values.length == schemaTypes.length) {
			for (int i = 0; i < values.length; i++) {
				System.out.println(values[i] + " : " + schemaTypes[i]);
				if (canBeParsedAsSchemaType(values[i], schemaTypes[i])) {
					continue;
				} else {
					return false;
				}
			}
			return true;
		}

		return false;
	}

	public Boolean canBeParsedAsSchemaType (String value, String schemaType) {
		Boolean canBeParsed = false;
		switch (schemaType) {
			case "long" : 
				try {
					Long longValue = new Long(value);
					canBeParsed = true;
				} catch (NumberFormatException nfe) {
					System.out.println("The value " + value + " could not be inserted as a long!");
				}
			break;
			case "double" :
				try {
					Double doubleValue = new Double(value);
					canBeParsed = true;
				} catch (NumberFormatException nfe) {
					System.out.println("The value " + value + " could not be inserted as a double!");
				}
			break; 
			case "char" : 
				if (value.length() == 1) {
					canBeParsed = true;
				} 
			break;
			case "string" :
				// DO NOTHING B/C we're lazy and allow any kind of data in
				System.out.println("HHHEERRERERE");
				canBeParsed = true;
			break;
			case "boolean" :
				if ((value.equalsIgnoreCase("true") || value.equalsIgnoreCase("false"))) {
					canBeParsed = true;
				} 
				break;	
		}
		System.out.println("PARSED ? " + canBeParsed);
		return canBeParsed;
	}

	public String[] getSchemaTypes (String fileType) {
		try {
			BufferedReader br = new BufferedReader(new FileReader(getFilePath(fileType)));
			String line = br.readLine();
			System.out.println("LINE : " + line);
			String [] schema = line.split("[,\\s]+");
			String [] schemaTypes = new String [(schema.length / 2)];

			for (int i = 1, j = 0; i < schema.length; i+=2, j++) {
				
				schemaTypes[j] = schema[i];
			} 
			return schemaTypes;
			
		} catch (IOException io) {
			System.out.println("CANNOT READ SCHEMA FILE!");
		}
		return new String []{};
	}

	public Boolean isSchemaProperlyFormatted (String schema) {
		// TODO Remove
		System.out.println("SCHEMA : " + schema);
		String [] nameAndDataType = schema.split("[,\\s]+");
		for (int i = 0; i < nameAndDataType.length; i++) {
			// TODO Remove
			System.out.println(i + " - " + nameAndDataType[i]);
			if (i % 2 == 1 && !validDatabaseTypes.contains(nameAndDataType[i])) {
				// TODO Remove
				System.out.println("PROBS FALSING");
				return false;
			}
		}
		return true;
	}

	public String toString () {
		return this.command + " " + this.objectType + " " + this.objectParameter + " " + 
			   this.option + " " + this.optionParameter + " " + this.extendedOption + " " +
			   this.extendedOptionParameter;
	}
}